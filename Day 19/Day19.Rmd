---
title: "Day 19 Notebook"
output: html_notebook
---

```{r setup, include=FALSE}
library(reshape2)
library(knitr)
library(dplyr)
library(stringr)
library(tidyverse)
library(readr)
library(collections)
options(scipen = 999)
```

```{r}
input<-read_lines("Day19Sample.txt")
instructions<-input[-1]
```

## Part 1
Starting with the stuff from day 16 - 
```{r}
addr<-function(a,b,c,reg){
  out<-reg
  out[c+1]<-reg[a+1]+reg[b+1]
  out}
addi<-function(a,b,c,reg){
  out<-reg
  out[c+1]<-reg[a+1]+b
  out}
mulr<-function(a,b,c,reg){
  out<-reg
  out[c+1]<-reg[a+1]*reg[b+1]
  out}
muli<-function(a,b,c,reg){
  out<-reg
  out[c+1]<-reg[a+1]*b
  out}
banr<-function(a,b,c,reg){
  out<-reg
  out[c+1]<-bitwAnd(reg[a+1],reg[b+1])
  out}
bani<-function(a,b,c,reg){
  out<-reg
  out[c+1]<-bitwAnd(reg[a+1],b)
  out}
borr<-function(a,b,c,reg){
  out<-reg
  out[c+1]<-bitwOr(reg[a+1],reg[b+1])
  out}
bori<-function(a,b,c,reg){
  out<-reg
  out[c+1]<-bitwOr(reg[a+1],b)
  out}
setr<-function(a,b,c,reg){
  out<-reg
  out[c+1]<-reg[a+1]
  out}
seti<-function(a,b,c,reg){
  out<-reg
  out[c+1]<-a
  out}
gtir<-function(a,b,c,reg){
  out<-reg
  if(a>reg[b+1]){out[c+1]<-1}else{out[c+1]<-0}
  out}
gtri<-function(a,b,c,reg){
  out<-reg
  if(reg[a+1]>b){out[c+1]<-1}else{out[c+1]<-0}
  out}
gtrr<-function(a,b,c,reg){
  out<-reg
  if(reg[a+1]>reg[b+1]){out[c+1]<-1}else{out[c+1]<-0}
  out}
eqir<-function(a,b,c,reg){
  out<-reg
  if(a==reg[b+1]){out[c+1]<-1}else{out[c+1]<-0}
  out}
eqri<-function(a,b,c,reg){
  out<-reg
  if(reg[a+1]==b){out[c+1]<-1}else{out[c+1]<-0}
  out}
eqrr<-function(a,b,c,reg){
  out<-reg
  if(reg[a+1]==reg[b+1]){out[c+1]<-1}else{out[c+1]<-0}
  out}
```



```{r}

###0 indexing is going to be the death of me - going to explicitly state ipreg (1 already added in)
runprogram<-function(instructions,ipreg){
  x<-1
  reg<-c(0,0,0,0,0,0)
  ip<-reg[ipreg]
  while(ip<length(instructions)){
    reg[ipreg]<-ip
    inst<-instructions[ip+1]
    inst<-unlist(str_split(inst," "))
    in2<-as.numeric(inst[[2]])
    in3<-as.numeric(inst[[3]])
    in4<-as.numeric(inst[[4]])
    reg<-do.call(inst[[1]],list(in2,in3,in4,reg))
    ip<-reg[ipreg]
    ip<-ip+1
    x<-x+1}
  cat(x,"\n")
reg}
```

```{r}
p1<-runprogram(instructions,2)
part1<-p1[1]
part1
```
##Part 2

Because part 2 depends on the instructions, not re-running it.

Obviously, there's a problem, so I won't even try.  (Especially since the original took 6,426,125 steps)
and reg[2] is always known because it is the value of the instruction

| # | instruction  | what is happening | jump |
|:------|:-----|:--------|:--------|
| 0 | addi 1 16 1 | reg[2]<- reg[2]+16 = 16| jump to 17 |
| 1 | seti 1 4 2 | reg[3]<-1 | |
| 2 | seti 1 0 3 | reg[4]<-1 | |
| 3 | mulr 2 3 4 | reg[5]<-reg[3]*reg[4] | |
| 4 | eqrr 4 5 4 | if(reg[5]==reg[6]){reg[5]<-1}else{reg[5]<-0} | if reg[5]==reg[6] go to statement 7, then 8 |
| 5 | addr 4 1 1 | reg[2]<-reg[5]+reg[2] = reg[5]+5 | skip straight to statement 8 |
| 6 | addi 1 1 1 | reg[2]<-reg[2] + 1 = 7 | |
| 7 | addr 2 0 0 | reg[1]<-reg[3] + reg [1] | |
| 8 | addi 3 1 3 | reg[4]<-reg[4] + 1 | |
| 9 | gtrr 3 5 4 | if(reg[4]>reg[6]){reg[5]<-1}else{reg[5]<-0} | if reg[4]>reg[6], leave the 3-11 loop |
| 10 | addr 1 4 1 | reg[2]<-reg[2]+reg[5] = 10 + reg[5] | |
| 11 | seti 2 4 1 | reg[2]<-2 | jump to statement 3 |
| 12 | addi 2 1 2 | reg[3]<-reg[3]+1 | |
| 13 | gtrr 2 5 4 | if(reg[3]>reg[6]){reg[5]<-1}else{reg[5]<-0} | if r[3]>r[6], leave the 2-to-15 loop |
| 14 | addr 4 1 1 | reg[2]<-reg[2]+reg[5] = 14+reg[5] | |
| 15 | seti 1 1 1 | reg[2]<-1 |  jump to statement 2 if r[2]<=r[6] |
| 16 | mulr 1 1 1 | reg[2]<-reg[2]^2 = 256 | leave the program |
| 17 | addi 5 2 5 | reg[6]<-reg[6]+2 | |
| 18 | mulr 5 5 5 | reg[6]<-reg[6]^2 | |
| 19 | mulr 1 5 5 | reg[6]<-reg[6]*reg[2] | |
| 20 | muli 5 11 5 | reg[6]<-reg[6]*11 | |
| 21 | addi 4 2 4 | reg[5]<-reg[5]+2 | |
| 22 | mulr 4 1 4 | reg[5]<-reg[5]\*reg[2] = reg[5]\*22 | |
| 23 | addi 4 16 4 | reg[5]<-reg[5]+16 | |
| 24 | addr 5 4 5 | reg[6]<-reg[6]+reg[5] | |
| 25 | addr 1 0 1 | reg[2]<-reg[2]+reg[1] = 25+reg[0] | jump to 27 |
| 26 | seti 0 7 1 | reg[2]<-0 | jump to statement 1|
| 27 | setr 1 5 4 | reg[5]<-reg[2] | |
| 28 | mulr 4 1 4 | reg[5]<-reg[5]\*reg[2]=reg[5]\*28 | |
| 29 | addr 1 4 4 | reg[5]<-reg[5]+reg[2]=reg[5]+29 | |
| 30 | mulr 1 4 4 | reg[5]<-reg[5]\*reg[2]=reg[5]\*30 | |
| 31 | muli 4 14 4 | reg[5]<-reg[5]*14 | |
| 32 | mulr 4 1 4 | reg[5]<-reg[5]\*reg[2]=reg[5]\*32 | |
| 33 | addr 5 4 5 | reg[6]<-reg[6]+reg[5] | |
| 34 | seti 0 9 0 | reg[1]<-0 | |
| 35 | seti 0 4 1 | reg[2]<-0 | jump to statement1|





```{r,eval=FALSE}
simpleprogram<-function(){
  reg<-c(0,0,0,0,0,0)
  reg[5]<-10550400   #17-35
  reg[6]<-10551296   #17-35
  reg[3]<-1   # 1
  while(reg[3]<=reg[6]){  #2-15 loop - increments reg[3]
    reg[4]<-1   
    while(reg[4]<=reg[6]){  #3-11 loop - increments reg[4]
      reg[5]<-reg[3]*reg[4]   
      if(reg[5]==reg[6]){    #4-8 if statement. kicks in when reg[3]&reg[4] multiply to 10551296     
        reg[5]<-1
        reg[1]<-reg[3]+reg[1] 
      }else{reg[5]<-0}  
      reg[4]<-reg[4]+1}
    reg[3]<-reg[3]+1}
reg}
```
Which looks like every time there's something that divides evenly into 10551296 (including itself), add it together to get the answer.

```{r,eval=FALSE}
part2<-1:10551296
part2<-part2[10551296 %% part2 == 0]
part2
part2<-sum(part2)
part2
```

